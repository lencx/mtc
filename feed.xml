<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>浮之静</title>
  <atom:link href="https://z.nofwl.com/feed.xml" rel="self" type="application/rss+xml" />
  <link>https://z.nofwl.com</link>
  <description>浮之静 技术社区</description>
  <item>
  <title><![CDATA[JavaScript 系列]]></title>
  <link>https://github.com/lencx/fzj/discussions/33</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/33</guid>
  <pubDate>2021-06-21</pubDate>
  <description><![CDATA[<p>JavaScript ( JS ) 是一种具有 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function" rel="nofollow">函数优先</a> 的轻量级，解释型或即时编译型的编程语言。JavaScript 是一种基于 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Prototype-based_programming" rel="nofollow">原型编程</a>、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。</p>
<hr>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> JavaScript 是什么？可以做什么？
<ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/get-started/ch1.md">[You Don't Know JS] What Is JavaScript?</a></li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> 构成 JavaScript 的 “砖块” - 常见类型的代码块，如条件语句、循环、函数及事件等。</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> JavaScript 对象初始 - 对象的设计思想和语法，如何创建对象等。</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> 异步 JavaScript - 怎样使用异步来有效处理潜在的阻塞操作，比如从服务器上获取资源。</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> 客户端 Web API</li>
</ul>]]></description>
</item>
<item>
  <title><![CDATA[TODO]]></title>
  <link>https://github.com/lencx/fzj/discussions/20</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/20</guid>
  <pubDate>2021-06-19</pubDate>
  <description><![CDATA[<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> js 学习计划</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> 移除 fzj token</li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox"> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" rel="nofollow">WebRTC 学习</a></li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> <a href="https://github.com/lencx/rgd">https://github.com/lencx/rgd</a> - github discussions 生成 RSS</li>
</ul>
<h3>开源</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> <code>xc-app</code> - <a href="https://github.com/lencx/create-xc-app/issues/1" data-hovercard-type="issue" data-hovercard-url="/lencx/create-xc-app/issues/1/hovercard">#1 脚手架优化</a></li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> <code>rsw</code> - 如果包名重复，启动会报错 <code>npm -g unlink &lt;pkg&gt;</code></li>
<li class="task-list-item"><input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""> <code>rsw</code> - <a href="https://github.com/lencx/vite-plugin-rsw/issues/9" data-hovercard-type="issue" data-hovercard-url="/lencx/vite-plugin-rsw/issues/9/hovercard">#9 rsw插件模板生成</a></li>
</ul>]]></description>
</item>
<item>
  <title><![CDATA[词汇表 - 中英文对照]]></title>
  <link>https://github.com/lencx/fzj/discussions/34</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/34</guid>
  <pubDate>2021-06-17</pubDate>
  <description><![CDATA[<table role="table">
<thead>
<tr>
<th>中文</th>
<th>英文</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用程序接口</td>
<td>Application Programming Interfaces</td>
<td>API</td>
</tr>
<tr>
<td>用户界面</td>
<td>User Interface</td>
<td></td>
</tr>
<tr>
<td>解释</td>
<td>interpret</td>
<td></td>
</tr>
<tr>
<td>编译</td>
<td>compile</td>
<td></td>
</tr>
<tr>
<td>即时编译</td>
<td>just-in-time compiling</td>
<td></td>
</tr>
<tr>
<td>服务器端</td>
<td>server-side</td>
<td></td>
</tr>
<tr>
<td>客户端</td>
<td>client-side</td>
<td></td>
</tr>
</tbody>
</table>]]></description>
</item>
<item>
  <title><![CDATA[this 关键字详解]]></title>
  <link>https://github.com/lencx/fzj/discussions/32</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/32</guid>
  <pubDate>2021-06-16</pubDate>
  <description><![CDATA[<h2>含义(Meaning)</h2>
<blockquote>
<p>在构造函数内部需要使用到<code>this</code>关键字。那么，<code>this</code>关键字到底是什么意思？<br>
<code>this</code>指向当前的运行环境：在JavaScript中，所有的函数都是在某个运行环境中运行，<code>this</code>就是这个运行环境。对JavaScript语言来说，一切皆对象，运行的环境也是对象，所以可以理解为所有的函数总是在某个对象之中运行，<code>this</code>就指向这个对象。<em>但是JavaScript支持运行环境动态切换，也就是说，this的指向是动态的，没有办法可以事先确定到底指向哪个对象</em></p>
<p>例：有一个函数<code>xOfVal</code>，同时充当<code>a</code>对象和<code>b</code>对象的<code>say</code>方法，用于打印当前运行环境中<code>x</code>变量的值。JavaScript允许函数<code>xOfVal</code>的运行环境动态切换，即一会属于<code>a</code>对象，一会属于<code>b</code>对象，这就需要靠<code>this</code>关键字来办到</p>
</blockquote>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="function xOfVal() {console.log(this.x)}
var a = {x: 5}
var b = {x: 7}
a.say = xOfVal
b.say = xOfVal
a.say() // 5
b.say() // 7
"><pre><span class="pl-k">function</span> <span class="pl-en">xOfVal</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span><span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">x</span><span class="pl-kos">)</span><span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-c1">x</span>: <span class="pl-c1">5</span><span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-s1">b</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-c1">x</span>: <span class="pl-c1">7</span><span class="pl-kos">}</span>
<span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">say</span> <span class="pl-c1">=</span> <span class="pl-s1">xOfVal</span>
<span class="pl-s1">b</span><span class="pl-kos">.</span><span class="pl-c1">say</span> <span class="pl-c1">=</span> <span class="pl-s1">xOfVal</span>
<span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-en">say</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// 5</span>
<span class="pl-s1">b</span><span class="pl-kos">.</span><span class="pl-en">say</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// 7</span></pre></div>
<p>当<code>xOfVal</code>属于对象<code>a</code>时，<code>this</code>指向<code>a</code>；当<code>xOfVal</code>属于对象<code>b</code>时， <code>this</code>指向<code>b</code>，<em>因此打印出不同的值</em>。由于<code>this</code>的指向是可变的，所以可以手动切换运行环境，以达到某种特定的目的。</p>
<p><em>结论</em>：<em><strong>如果一个函数在全局环境中运行，<code>this</code>就是指向顶层对象(浏览器中为<code>window</code>对象)；如果一个函数作为某个对象的方法运行，<code>this</code>就是指向那个对象。 可以近似认为，<code>this</code>事所有函数运行时的一个隐藏参数，决定了函数的运行环境。</strong></em></p>
<h2>使用场合(Using The Occasion)</h2>
<h3>全局环境(Global Context)</h3>
<blockquote>
<p>在全局环境中使用<code>this</code>，它指的时顶层对象window。</p>
</blockquote>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="console.log(this === window) // true
function fn() {
    console.log(this === window)
}
fn() // true
"><pre><span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span> <span class="pl-c1">===</span> <span class="pl-smi">window</span><span class="pl-kos">)</span> <span class="pl-c">// true</span>
<span class="pl-k">function</span> <span class="pl-en">fn</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span> <span class="pl-c1">===</span> <span class="pl-smi">window</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>
<span class="pl-en">fn</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// true</span></pre></div>
<p><em>结论</em>： <em><strong><code>this</code>不论是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指向全局对象<code>window</code></strong></em></p>
<h3>构造函数(Constructor)</h3>
<blockquote>
<p>在构造函数中使用<code>this</code>，它指的是实例对象</p>
</blockquote>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="// 构造函数A
var A = function(x) {
    // this指向实例对象
    // 所以在构造函数内部定义`this.x`，就相当于定义实例对象有一个`x`属性
    this.x = x
}
// `say`方法可以返回这个`x`属性
A.prototype.say = function() {
    return this.x
}
var a = new A(3)
a.x // 3
a.say() // 3
"><pre><span class="pl-c">// 构造函数A</span>
<span class="pl-k">var</span> <span class="pl-v">A</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">x</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-c">// this指向实例对象</span>
    <span class="pl-c">// 所以在构造函数内部定义`this.x`，就相当于定义实例对象有一个`x`属性</span>
    <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">x</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span>
<span class="pl-kos">}</span>
<span class="pl-c">// `say`方法可以返回这个`x`属性</span>
<span class="pl-v">A</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-en">say</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-k">return</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">x</span>
<span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-v">A</span><span class="pl-kos">(</span><span class="pl-c1">3</span><span class="pl-kos">)</span>
<span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">x</span> <span class="pl-c">// 3</span>
<span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-en">say</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// 3</span></pre></div>
<h3>对象方法(Object Method)</h3>
<ul>
<li>当<code>a</code>对象的方法被赋予<code>b</code>对象，该方法就变成了普通函数。其中的<code>this</code>就从指向<code>a</code>对象变成指向<code>b</code>对象。这就是<code>this</code>取决于运行时所在的对象的含义。<em>需要特别小心。如果将某个对象的方法赋值给另一个对象，会改变<code>this</code>的指向。</em></li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var a = {
    // `prop`是`a`对象的属性
    prop: 'hello',
    // `f`是`a`对象的方法
    f: function() {
        return this.prop
    }
}
a.f() // hello
var b = new Object()
b.prop = 'hello, lencx'
// `f`是`a`对象的方法
b.f = a.f
// 如果在`b`对象上调用这个方法。`f`方法中的`this`就会指向`b`
// 说明JavaScript函数的运行环境完全是动态绑定的，可以在运行时切换。
b.f() // hello, lencx
"><pre><span class="pl-k">var</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c">// `prop`是`a`对象的属性</span>
    <span class="pl-c1">prop</span>: <span class="pl-s">'hello'</span><span class="pl-kos">,</span>
    <span class="pl-c">// `f`是`a`对象的方法</span>
    <span class="pl-en">f</span>: <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-k">return</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">prop</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span>
<span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-en">f</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// hello</span>
<span class="pl-k">var</span> <span class="pl-s1">b</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-v">Object</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-s1">b</span><span class="pl-kos">.</span><span class="pl-c1">prop</span> <span class="pl-c1">=</span> <span class="pl-s">'hello, lencx'</span>
<span class="pl-c">// `f`是`a`对象的方法</span>
<span class="pl-s1">b</span><span class="pl-kos">.</span><span class="pl-c1">f</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">f</span>
<span class="pl-c">// 如果在`b`对象上调用这个方法。`f`方法中的`this`就会指向`b`</span>
<span class="pl-c">// 说明JavaScript函数的运行环境完全是动态绑定的，可以在运行时切换。</span>
<span class="pl-s1">b</span><span class="pl-kos">.</span><span class="pl-en">f</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// hello, lencx</span></pre></div>
<ul>
<li>如果不想改变<code>this</code>的指向，可以将<code>b.f</code>改写为</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="b.f = function() {
    // `f`方法是在`a`对象下运行，所以`this`指向`a`
    return a.f()
}
b.f() // hello
"><pre><span class="pl-s1">b</span><span class="pl-kos">.</span><span class="pl-en">f</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-c">// `f`方法是在`a`对象下运行，所以`this`指向`a`</span>
    <span class="pl-k">return</span> <span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-en">f</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>
<span class="pl-s1">b</span><span class="pl-kos">.</span><span class="pl-en">f</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// hello</span></pre></div>
<ul>
<li>有时，某个方法位于多层对象的内部，这时如果为了简化书写，把该方法赋值给一个变量，往往会得到意想不到的结果。</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var a = {
    b: {
        prop: 'hello, lencx',
        say: function() {
            console.log(this.prop)
        }
    }
}
// `say`属于多层对象内部的一个方法。为求简写，将其赋值给`hello`变量
var hello = a.b.say
// 调用时，`this`指向全局对象(window)
hello() // undefined
// 为了避免这个问题，可以将`say`方法所在的对象赋值给`hello2`
var hello2 = a.b
// 调用时，`this`指向不变，即指向对象`b`
hello2.say()
"><pre><span class="pl-k">var</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">b</span>: <span class="pl-kos">{</span>
        <span class="pl-c1">prop</span>: <span class="pl-s">'hello, lencx'</span><span class="pl-kos">,</span>
        <span class="pl-en">say</span>: <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
            <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">prop</span><span class="pl-kos">)</span>
        <span class="pl-kos">}</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span>
<span class="pl-c">// `say`属于多层对象内部的一个方法。为求简写，将其赋值给`hello`变量</span>
<span class="pl-k">var</span> <span class="pl-s1">hello</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">b</span><span class="pl-kos">.</span><span class="pl-c1">say</span>
<span class="pl-c">// 调用时，`this`指向全局对象(window)</span>
<span class="pl-s1">hello</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// undefined</span>
<span class="pl-c">// 为了避免这个问题，可以将`say`方法所在的对象赋值给`hello2`</span>
<span class="pl-k">var</span> <span class="pl-s1">hello2</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">b</span>
<span class="pl-c">// 调用时，`this`指向不变，即指向对象`b`</span>
<span class="pl-s1">hello2</span><span class="pl-kos">.</span><span class="pl-en">say</span><span class="pl-kos">(</span><span class="pl-kos">)</span></pre></div>
<h3>箭头函数(Arrow functions)</h3>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var foo = (() =&gt; this)
// 在全局环境中调用`foo`，`this`指向`window`
console.log(foo() === window) // true
var a = {}
// 作为`a`对象的`fn`方法调用
a.fn = foo
console.log(a.fn() === window) // true
// 使用`call`
console.log(foo.call(a) === window) // true
// 使用`bind`
foo = foo.bind(a)
console.log(foo() === window) // true
"><pre><span class="pl-k">var</span> <span class="pl-s1">foo</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-smi">this</span><span class="pl-kos">)</span>
<span class="pl-c">// 在全局环境中调用`foo`，`this`指向`window`</span>
<span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">foo</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">===</span> <span class="pl-smi">window</span><span class="pl-kos">)</span> <span class="pl-c">// true</span>
<span class="pl-k">var</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-kos">}</span>
<span class="pl-c">// 作为`a`对象的`fn`方法调用</span>
<span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">fn</span> <span class="pl-c1">=</span> <span class="pl-s1">foo</span>
<span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-en">fn</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">===</span> <span class="pl-smi">window</span><span class="pl-kos">)</span> <span class="pl-c">// true</span>
<span class="pl-c">// 使用`call`</span>
<span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">foo</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-s1">a</span><span class="pl-kos">)</span> <span class="pl-c1">===</span> <span class="pl-smi">window</span><span class="pl-kos">)</span> <span class="pl-c">// true</span>
<span class="pl-c">// 使用`bind`</span>
<span class="pl-s1">foo</span> <span class="pl-c1">=</span> <span class="pl-s1">foo</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-s1">a</span><span class="pl-kos">)</span>
<span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">foo</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">===</span> <span class="pl-smi">window</span><span class="pl-kos">)</span> <span class="pl-c">// true</span></pre></div>
<p><em>结论</em>：<em><strong>无论使用何种办法，<code>foo</code>方法的<code>this</code>指向都是创建时的指向(window)。这个结论同样适用于在其他函数内部创建的箭头函数。<code>this</code>指向创建它的对象。</strong></em></p>
<p>例：</p>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var obj = {foo: function() {
    var x = (() =&gt; this)
    // var x = function() {
    //     return this
    // }
    return x
}}
var fn = obj.foo()
console.log(fn() === obj) // true
// 但是请注意，如果将`foo`所在的对象赋值给一个变量`fn2`，而不是调用`foo`方法
var fn2 = obj.foo
// 然后调用该方法，则`this`指向`window`，因为它遵循所在的对象运行环境
console.log(fn2()() === window) // true
"><pre><span class="pl-k">var</span> <span class="pl-s1">obj</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-en">foo</span>: <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-k">var</span> <span class="pl-s1">x</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-smi">this</span><span class="pl-kos">)</span>
    <span class="pl-c">// var x = function() {</span>
    <span class="pl-c">//     return this</span>
    <span class="pl-c">// }</span>
    <span class="pl-k">return</span> <span class="pl-s1">x</span>
<span class="pl-kos">}</span><span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-s1">fn</span> <span class="pl-c1">=</span> <span class="pl-s1">obj</span><span class="pl-kos">.</span><span class="pl-en">foo</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">fn</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">===</span> <span class="pl-s1">obj</span><span class="pl-kos">)</span> <span class="pl-c">// true</span>
<span class="pl-c">// 但是请注意，如果将`foo`所在的对象赋值给一个变量`fn2`，而不是调用`foo`方法</span>
<span class="pl-k">var</span> <span class="pl-s1">fn2</span> <span class="pl-c1">=</span> <span class="pl-s1">obj</span><span class="pl-kos">.</span><span class="pl-c1">foo</span>
<span class="pl-c">// 然后调用该方法，则`this`指向`window`，因为它遵循所在的对象运行环境</span>
<span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">fn2</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">===</span> <span class="pl-smi">window</span><span class="pl-kos">)</span> <span class="pl-c">// true</span></pre></div>
<h3>对象定义新属性方法(Getter Or Setter)</h3>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="function sum() {
    return this.x + this.y + this.z
}
var numObj = {
    x: 3,
    y: 5,
    z: 7,
    get average() {
        return (this.x + this.y + this.z) / 3
    }
}
Object.defineProperty(numObj, 'sum', {
    get: sum,
    enumerable: true,
    configurable: true
})
console.log(numObj.average, numObj.sum) // 5 15
"><pre><span class="pl-k">function</span> <span class="pl-en">sum</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-k">return</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">x</span> <span class="pl-c1">+</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">y</span> <span class="pl-c1">+</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">z</span>
<span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-s1">numObj</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">x</span>: <span class="pl-c1">3</span><span class="pl-kos">,</span>
    <span class="pl-c1">y</span>: <span class="pl-c1">5</span><span class="pl-kos">,</span>
    <span class="pl-c1">z</span>: <span class="pl-c1">7</span><span class="pl-kos">,</span>
    <span class="pl-k">get</span> <span class="pl-en">average</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-k">return</span> <span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">x</span> <span class="pl-c1">+</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">y</span> <span class="pl-c1">+</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">z</span><span class="pl-kos">)</span> <span class="pl-c1">/</span> <span class="pl-c1">3</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span>
<span class="pl-v">Object</span><span class="pl-kos">.</span><span class="pl-en">defineProperty</span><span class="pl-kos">(</span><span class="pl-s1">numObj</span><span class="pl-kos">,</span> <span class="pl-s">'sum'</span><span class="pl-kos">,</span> <span class="pl-kos">{</span>
    <span class="pl-c1">get</span>: <span class="pl-s1">sum</span><span class="pl-kos">,</span>
    <span class="pl-c1">enumerable</span>: <span class="pl-c1">true</span><span class="pl-kos">,</span>
    <span class="pl-c1">configurable</span>: <span class="pl-c1">true</span>
<span class="pl-kos">}</span><span class="pl-kos">)</span>
<span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">numObj</span><span class="pl-kos">.</span><span class="pl-c1">average</span><span class="pl-kos">,</span> <span class="pl-s1">numObj</span><span class="pl-kos">.</span><span class="pl-c1">sum</span><span class="pl-kos">)</span> <span class="pl-c">// 5 15</span></pre></div>
<h3>Node.js</h3>
<p>在node.js，<code>this</code>分成两种情况。在全局环境中，<code>this</code>指向全局对象<code>global</code>；在模块环境中，<code>this</code>指向<code>module.exports</code></p>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="// 全局环境中
this === global // true
// 模块环境中
this === module.exports // true
"><pre><span class="pl-c">// 全局环境中</span>
<span class="pl-smi">this</span> <span class="pl-c1">===</span> <span class="pl-s1">global</span> <span class="pl-c">// true</span>
<span class="pl-c">// 模块环境中</span>
<span class="pl-smi">this</span> <span class="pl-c1">===</span> <span class="pl-smi">module</span><span class="pl-kos">.</span><span class="pl-c1">exports</span> <span class="pl-c">// true</span></pre></div>
<h2>使用注意事项(Note)</h2>
<h3>避免多层<code>this</code></h3>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var o = {
    f1: function() {
        console.log(this) // f1
        var f2 = function() {
            console.log(this) // window
        }()
    }
}
o.f1()
// 解决办法:
var o2 = {
    f1: function() {
        console.log(this) // f1
        // 使用`that`对`this`进行固定
        var that = this
        var f2 = function() {
            // 使用`that`代替原来的`this`
            console.log(that) // f1
        }()
    }
}
o2.f1()
"><pre><span class="pl-k">var</span> <span class="pl-s1">o</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-en">f1</span>: <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">)</span> <span class="pl-c">// f1</span>
        <span class="pl-k">var</span> <span class="pl-s1">f2</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
            <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">)</span> <span class="pl-c">// window</span>
        <span class="pl-kos">}</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span>
<span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-en">f1</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-c">// 解决办法:</span>
<span class="pl-k">var</span> <span class="pl-s1">o2</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-en">f1</span>: <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">)</span> <span class="pl-c">// f1</span>
        <span class="pl-c">// 使用`that`对`this`进行固定</span>
        <span class="pl-k">var</span> <span class="pl-s1">that</span> <span class="pl-c1">=</span> <span class="pl-smi">this</span>
        <span class="pl-k">var</span> <span class="pl-s1">f2</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
            <span class="pl-c">// 使用`that`代替原来的`this`</span>
            <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">that</span><span class="pl-kos">)</span> <span class="pl-c">// f1</span>
        <span class="pl-kos">}</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span>
<span class="pl-s1">o2</span><span class="pl-kos">.</span><span class="pl-en">f1</span><span class="pl-kos">(</span><span class="pl-kos">)</span></pre></div>
<h3>避免数组处理方法中的<code>this</code></h3>
<p>数组的<code>map</code>, <code>reduce</code>, <code>some</code>, <code>filter</code>, <code>forEach</code>等方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code>。</p>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var o = {
    a: 'hello',
    b: ['lencx', 'a1', 'a2'],
    fn: function() {
        this.b.map(function(item) {
            console.log(`${this.a}, ${item}`)
        })
    }
}
// undefined, lencx
// undefined, a1
// undefined, a2
o.fn()
// ------------------------------------------
// 解决办法一：
// 使用中间变量
var o2 = {
    a: 'hello',
    b: ['lencx', 'a1', 'a2'],
    fn: function() {
        var that = this
        this.b.map(function(item) {
            console.log(`${that.a}, ${item}`)
        })
    }
}
// hello, lencx
// hello, a1
// hello, a2
o2.f()
// ------------------------------------------
// 解决办法二：
// 将`this`当作`map`方法的第二个参数，固定它的运行环境
var o3 = {
    a: 'hello',
    b: ['lencx', 'a1', 'a2'],
    fn: function() {
        this.b.map(function(item) {
            console.log(`${this.a}, ${item}`)
        }, this)
    }
}
// hello, lencx
// hello, a1
// hello, a2
o3.fn()
"><pre><span class="pl-k">var</span> <span class="pl-s1">o</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">a</span>: <span class="pl-s">'hello'</span><span class="pl-kos">,</span>
    <span class="pl-c1">b</span>: <span class="pl-kos">[</span><span class="pl-s">'lencx'</span><span class="pl-kos">,</span> <span class="pl-s">'a1'</span><span class="pl-kos">,</span> <span class="pl-s">'a2'</span><span class="pl-kos">]</span><span class="pl-kos">,</span>
    <span class="pl-en">fn</span>: <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">b</span><span class="pl-kos">.</span><span class="pl-en">map</span><span class="pl-kos">(</span><span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">item</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
            <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s">`<span class="pl-s1"><span class="pl-kos">${</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">a</span><span class="pl-kos">}</span></span>, <span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">item</span><span class="pl-kos">}</span></span>`</span><span class="pl-kos">)</span>
        <span class="pl-kos">}</span><span class="pl-kos">)</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span>
<span class="pl-c">// undefined, lencx</span>
<span class="pl-c">// undefined, a1</span>
<span class="pl-c">// undefined, a2</span>
<span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-en">fn</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-c">// ------------------------------------------</span>
<span class="pl-c">// 解决办法一：</span>
<span class="pl-c">// 使用中间变量</span>
<span class="pl-k">var</span> <span class="pl-s1">o2</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">a</span>: <span class="pl-s">'hello'</span><span class="pl-kos">,</span>
    <span class="pl-c1">b</span>: <span class="pl-kos">[</span><span class="pl-s">'lencx'</span><span class="pl-kos">,</span> <span class="pl-s">'a1'</span><span class="pl-kos">,</span> <span class="pl-s">'a2'</span><span class="pl-kos">]</span><span class="pl-kos">,</span>
    <span class="pl-en">fn</span>: <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-k">var</span> <span class="pl-s1">that</span> <span class="pl-c1">=</span> <span class="pl-smi">this</span>
        <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">b</span><span class="pl-kos">.</span><span class="pl-en">map</span><span class="pl-kos">(</span><span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">item</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
            <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s">`<span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">that</span><span class="pl-kos">.</span><span class="pl-c1">a</span><span class="pl-kos">}</span></span>, <span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">item</span><span class="pl-kos">}</span></span>`</span><span class="pl-kos">)</span>
        <span class="pl-kos">}</span><span class="pl-kos">)</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span>
<span class="pl-c">// hello, lencx</span>
<span class="pl-c">// hello, a1</span>
<span class="pl-c">// hello, a2</span>
<span class="pl-s1">o2</span><span class="pl-kos">.</span><span class="pl-en">f</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-c">// ------------------------------------------</span>
<span class="pl-c">// 解决办法二：</span>
<span class="pl-c">// 将`this`当作`map`方法的第二个参数，固定它的运行环境</span>
<span class="pl-k">var</span> <span class="pl-s1">o3</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">a</span>: <span class="pl-s">'hello'</span><span class="pl-kos">,</span>
    <span class="pl-c1">b</span>: <span class="pl-kos">[</span><span class="pl-s">'lencx'</span><span class="pl-kos">,</span> <span class="pl-s">'a1'</span><span class="pl-kos">,</span> <span class="pl-s">'a2'</span><span class="pl-kos">]</span><span class="pl-kos">,</span>
    <span class="pl-en">fn</span>: <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">b</span><span class="pl-kos">.</span><span class="pl-en">map</span><span class="pl-kos">(</span><span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">item</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
            <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s">`<span class="pl-s1"><span class="pl-kos">${</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">a</span><span class="pl-kos">}</span></span>, <span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">item</span><span class="pl-kos">}</span></span>`</span><span class="pl-kos">)</span>
        <span class="pl-kos">}</span><span class="pl-kos">,</span> <span class="pl-smi">this</span><span class="pl-kos">)</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span>
<span class="pl-c">// hello, lencx</span>
<span class="pl-c">// hello, a1</span>
<span class="pl-c">// hello, a2</span>
<span class="pl-s1">o3</span><span class="pl-kos">.</span><span class="pl-en">fn</span><span class="pl-kos">(</span><span class="pl-kos">)</span></pre></div>
<h3>避免回调函数中的<code>this</code></h3>
<blockquote>
<p>回调函数中的<code>this</code>往往会改变指向，最好避免使用</p>
</blockquote>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var o = new Object()
o.f = function() {
    console.log(this === o)
}
o.f() // true
// `this`不再指向`o`对象，而是指向按钮的DOM对象
// 因为`f`方法是在按钮对象的环境中被调用的
document.querySelector('#btn').addEventListener('click', o.f)
"><pre><span class="pl-k">var</span> <span class="pl-s1">o</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-v">Object</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-en">f</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span> <span class="pl-c1">===</span> <span class="pl-s1">o</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>
<span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-en">f</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// true</span>
<span class="pl-c">// `this`不再指向`o`对象，而是指向按钮的DOM对象</span>
<span class="pl-c">// 因为`f`方法是在按钮对象的环境中被调用的</span>
<span class="pl-smi">document</span><span class="pl-kos">.</span><span class="pl-en">querySelector</span><span class="pl-kos">(</span><span class="pl-s">'#btn'</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">addEventListener</span><span class="pl-kos">(</span><span class="pl-s">'click'</span><span class="pl-kos">,</span> <span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-c1">f</span><span class="pl-kos">)</span></pre></div>
<h2>固定<code>this</code>的方法(Fixed this)</h2>
<p><code>this</code>的动态切换，为JavaScript创造了巨大的灵活性，但也使编程变得困难和模糊。有时需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript提供了<code>call</code>, <code>apply</code>, <code>bind</code>三个方法，来切换/固定<code>this</code>的指向。</p>
<h3><code>call</code>方法</h3>
<blockquote>
<p>Syntax: function.call(thisArg, arg1, arg2, ...)<br>
第一个参数<code>thisArg</code>就是<code>this</code>所要指向的对象，之后的参数<code>arg1, arg2, ...</code>则是函数调用时所需的参数。</p>
</blockquote>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="// 例1:
var o = {}
var f = function () {
    return this
}
f() === window // true
f.call(o) === o // true
// 例2:
var num = 111
var num2 = {num: 222}
function sayNum() {
    console.log(this.num)
}
sayNum.call() // 111
sayNum.call(window) // 111
sayNum.call(num2) // 222
"><pre><span class="pl-c">// 例1:</span>
<span class="pl-k">var</span> <span class="pl-s1">o</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-en">f</span> <span class="pl-c1">=</span> <span class="pl-k">function</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-k">return</span> <span class="pl-smi">this</span>
<span class="pl-kos">}</span>
<span class="pl-en">f</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">===</span> <span class="pl-smi">window</span> <span class="pl-c">// true</span>
<span class="pl-en">f</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-s1">o</span><span class="pl-kos">)</span> <span class="pl-c1">===</span> <span class="pl-s1">o</span> <span class="pl-c">// true</span>
<span class="pl-c">// 例2:</span>
<span class="pl-k">var</span> <span class="pl-s1">num</span> <span class="pl-c1">=</span> <span class="pl-c1">111</span>
<span class="pl-k">var</span> <span class="pl-s1">num2</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-c1">num</span>: <span class="pl-c1">222</span><span class="pl-kos">}</span>
<span class="pl-k">function</span> <span class="pl-en">sayNum</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">num</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>
<span class="pl-s1">sayNum</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// 111</span>
<span class="pl-s1">sayNum</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-smi">window</span><span class="pl-kos">)</span> <span class="pl-c">// 111</span>
<span class="pl-s1">sayNum</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-s1">num2</span><span class="pl-kos">)</span> <span class="pl-c">// 222</span></pre></div>
<p><code>call</code>的应用：调用对象的原生方法</p>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var obj = {}
obj.hasOwnProperty('map') // false
obj.hasOwnProperty = function() {
    return true
}
obj.hasOwnProperty('map') // true
Object.prototype.hasOwnProperty.call(obj, 'map') // false
"><pre><span class="pl-k">var</span> <span class="pl-s1">obj</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-kos">}</span>
<span class="pl-s1">obj</span><span class="pl-kos">.</span><span class="pl-en">hasOwnProperty</span><span class="pl-kos">(</span><span class="pl-s">'map'</span><span class="pl-kos">)</span> <span class="pl-c">// false</span>
<span class="pl-s1">obj</span><span class="pl-kos">.</span><span class="pl-en">hasOwnProperty</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-k">return</span> <span class="pl-c1">true</span>
<span class="pl-kos">}</span>
<span class="pl-s1">obj</span><span class="pl-kos">.</span><span class="pl-en">hasOwnProperty</span><span class="pl-kos">(</span><span class="pl-s">'map'</span><span class="pl-kos">)</span> <span class="pl-c">// true</span>
<span class="pl-v">Object</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">hasOwnProperty</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-s1">obj</span><span class="pl-kos">,</span> <span class="pl-s">'map'</span><span class="pl-kos">)</span> <span class="pl-c">// false</span></pre></div>
<p><code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就得不到正确的结果。<code>call</code>方法则可以解决这个问题。它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响其结果。</p>
<h3><code>apply</code>方法</h3>
<blockquote>
<p>Syntax: func.apply(thisArg, [argsArray])<br>
<code>apply</code>方法与<code>call</code>类似，也是改变<code>this</code>指向，然后再调用该函数。唯一区别是，它接收一个数组作为函数执行时的参数。</p>
</blockquote>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="function sum(x, y) {
    console.log(x + y)
}
sum.call(null, 2, 4) // 6
sum.apply(null, [2, 4]) // 6
// --------------------------------------------------
// 对字符串中的单个字符进行重复操作
//Uncaught TypeError: &quot;abcd&quot;.map is not a function
'abcd'.map(i =&gt; console.log(i))
// aabbccdd
Array.prototype.map.call('abcd', i =&gt; i+i).join('')
"><pre><span class="pl-k">function</span> <span class="pl-en">sum</span><span class="pl-kos">(</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">y</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">x</span> <span class="pl-c1">+</span> <span class="pl-s1">y</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>
<span class="pl-s1">sum</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-c1">null</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">4</span><span class="pl-kos">)</span> <span class="pl-c">// 6</span>
<span class="pl-s1">sum</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-c1">null</span><span class="pl-kos">,</span> <span class="pl-kos">[</span><span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">4</span><span class="pl-kos">]</span><span class="pl-kos">)</span> <span class="pl-c">// 6</span>
<span class="pl-c">// --------------------------------------------------</span>
<span class="pl-c">// 对字符串中的单个字符进行重复操作</span>
<span class="pl-c">//Uncaught TypeError: "abcd".map is not a function</span>
<span class="pl-s">'abcd'</span><span class="pl-kos">.</span><span class="pl-en">map</span><span class="pl-kos">(</span><span class="pl-s1">i</span> <span class="pl-c1">=&gt;</span> <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">i</span><span class="pl-kos">)</span><span class="pl-kos">)</span>
<span class="pl-c">// aabbccdd</span>
<span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">map</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-s">'abcd'</span><span class="pl-kos">,</span> <span class="pl-s1">i</span> <span class="pl-c1">=&gt;</span> <span class="pl-s1">i</span><span class="pl-c1">+</span><span class="pl-s1">i</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">join</span><span class="pl-kos">(</span><span class="pl-s">''</span><span class="pl-kos">)</span></pre></div>
<h4>应用(Use)</h4>
<ul>
<li>找出数组中最大/最小的元素</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var a = [4, 7, 3, 9, 11, 1]
Math.max.apply(null, a) // 11
Math.min.apply(null, a) // 1
"><pre><span class="pl-k">var</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">4</span><span class="pl-kos">,</span> <span class="pl-c1">7</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">,</span> <span class="pl-c1">9</span><span class="pl-kos">,</span> <span class="pl-c1">11</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">]</span>
<span class="pl-v">Math</span><span class="pl-kos">.</span><span class="pl-c1">max</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-c1">null</span><span class="pl-kos">,</span> <span class="pl-s1">a</span><span class="pl-kos">)</span> <span class="pl-c">// 11</span>
<span class="pl-v">Math</span><span class="pl-kos">.</span><span class="pl-c1">min</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-c1">null</span><span class="pl-kos">,</span> <span class="pl-s1">a</span><span class="pl-kos">)</span> <span class="pl-c">// 1</span></pre></div>
<ul>
<li>将数组的空元素变为<code>undefined</code>(数组遍历会跳过空元素，但是不会跳过undefined)</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="Array.apply(null, [1, 2, , 3]) // [1, 2, undefined, 3]
"><pre><span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-c1">null</span><span class="pl-kos">,</span> <span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">]</span><span class="pl-kos">)</span> <span class="pl-c">// [1, 2, undefined, 3]</span></pre></div>
<ul>
<li>转换类似数组的对象(被处理的对象必须有<code>length</code>属性，以及相对应的数字键)</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="// 例1:
var o = {
    0: 1,
    1: 3,
    length: 2
}
Array.prototype.slice.apply(o) // [1, 3]
// 例2:
var o2 = {
    0: 1,
    1: 3
}
Array.prototype.slice.apply(o2) // []
// 例3:
var o3 = {
    0: 1,
    1: 3,
    length: 4
}
Array.prototype.slice.apply(o3) // [1, 3, empty × 2]
// 例4:
var o4 = {
    1: 1,
    a: 3,
    length: 2
}
Array.prototype.slice.apply(o4) // [empty, 1]
"><pre><span class="pl-c">// 例1:</span>
<span class="pl-k">var</span> <span class="pl-s1">o</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">0</span>: <span class="pl-c1">1</span><span class="pl-kos">,</span>
    <span class="pl-c1">1</span>: <span class="pl-c1">3</span><span class="pl-kos">,</span>
    <span class="pl-c1">length</span>: <span class="pl-c1">2</span>
<span class="pl-kos">}</span>
<span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">slice</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-s1">o</span><span class="pl-kos">)</span> <span class="pl-c">// [1, 3]</span>
<span class="pl-c">// 例2:</span>
<span class="pl-k">var</span> <span class="pl-s1">o2</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">0</span>: <span class="pl-c1">1</span><span class="pl-kos">,</span>
    <span class="pl-c1">1</span>: <span class="pl-c1">3</span>
<span class="pl-kos">}</span>
<span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">slice</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-s1">o2</span><span class="pl-kos">)</span> <span class="pl-c">// []</span>
<span class="pl-c">// 例3:</span>
<span class="pl-k">var</span> <span class="pl-s1">o3</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">0</span>: <span class="pl-c1">1</span><span class="pl-kos">,</span>
    <span class="pl-c1">1</span>: <span class="pl-c1">3</span><span class="pl-kos">,</span>
    <span class="pl-c1">length</span>: <span class="pl-c1">4</span>
<span class="pl-kos">}</span>
<span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">slice</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-s1">o3</span><span class="pl-kos">)</span> <span class="pl-c">// [1, 3, empty × 2]</span>
<span class="pl-c">// 例4:</span>
<span class="pl-k">var</span> <span class="pl-s1">o4</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">1</span>: <span class="pl-c1">1</span><span class="pl-kos">,</span>
    <span class="pl-c1">a</span>: <span class="pl-c1">3</span><span class="pl-kos">,</span>
    <span class="pl-c1">length</span>: <span class="pl-c1">2</span>
<span class="pl-kos">}</span>
<span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">slice</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-s1">o4</span><span class="pl-kos">)</span> <span class="pl-c">// [empty, 1]</span></pre></div>
<ul>
<li>绑定回调函数的对象(之前<a href="#%E9%81%BF%E5%85%8D%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this">绑定按钮点击事件</a>的例子)</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var o = new Object()
o.f = function() {
    console.log(this === o)
}
// `apply`或者`call`方法不仅绑定函数执行时所在的对象，还会立即执行函数。因此要把绑定语句写在一个函数体内。
var foo = function() {
    // o.f.call(o)
    o.f.apply(o)
}
// true
document.querySelector('#btn').addEventListener('click', foo)
"><pre><span class="pl-k">var</span> <span class="pl-s1">o</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-v">Object</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-en">f</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span> <span class="pl-c1">===</span> <span class="pl-s1">o</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>
<span class="pl-c">// `apply`或者`call`方法不仅绑定函数执行时所在的对象，还会立即执行函数。因此要把绑定语句写在一个函数体内。</span>
<span class="pl-k">var</span> <span class="pl-en">foo</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-c">// o.f.call(o)</span>
    <span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-c1">f</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-s1">o</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>
<span class="pl-c">// true</span>
<span class="pl-smi">document</span><span class="pl-kos">.</span><span class="pl-en">querySelector</span><span class="pl-kos">(</span><span class="pl-s">'#btn'</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">addEventListener</span><span class="pl-kos">(</span><span class="pl-s">'click'</span><span class="pl-kos">,</span> <span class="pl-en">foo</span><span class="pl-kos">)</span></pre></div>
<h3><code>bind</code>方法</h3>
<blockquote>
<p>Syntax: fun.bind(thisArg[, arg1[, arg2[, ...]]])</p>
</blockquote>
<ul>
<li><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var o = new Object()
o.name = 'lencx'
o.say = function() {
    console.log(this.name)
}
o.say() // lencx
var o2 = new Object()
o2.name = 'len'
o2.say = o.say
o2.say() // len
o2.say = o.say.bind(o)
o2.say() // lencx
"><pre><span class="pl-k">var</span> <span class="pl-s1">o</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-v">Object</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-c1">name</span> <span class="pl-c1">=</span> <span class="pl-s">'lencx'</span>
<span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-en">say</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">name</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>
<span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-en">say</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// lencx</span>
<span class="pl-k">var</span> <span class="pl-s1">o2</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-v">Object</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-s1">o2</span><span class="pl-kos">.</span><span class="pl-c1">name</span> <span class="pl-c1">=</span> <span class="pl-s">'len'</span>
<span class="pl-s1">o2</span><span class="pl-kos">.</span><span class="pl-c1">say</span> <span class="pl-c1">=</span> <span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-c1">say</span>
<span class="pl-s1">o2</span><span class="pl-kos">.</span><span class="pl-en">say</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// len</span>
<span class="pl-s1">o2</span><span class="pl-kos">.</span><span class="pl-c1">say</span> <span class="pl-c1">=</span> <span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-c1">say</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-s1">o</span><span class="pl-kos">)</span>
<span class="pl-s1">o2</span><span class="pl-kos">.</span><span class="pl-en">say</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// lencx</span></pre></div>
<ul>
<li><code>bind</code>除了可以绑定<code>this</code>以外，还可以绑定原函数的参数</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var sum = function(x, y) {
    return x * this.a + y * this.b
}
var nums = {
    a: 3,
    b: 4
}
var newSum = sum.bind(nums, 3)
newSum(3)
"><pre><span class="pl-k">var</span> <span class="pl-en">sum</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">x</span><span class="pl-kos">,</span> <span class="pl-s1">y</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-k">return</span> <span class="pl-s1">x</span> <span class="pl-c1">*</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">a</span> <span class="pl-c1">+</span> <span class="pl-s1">y</span> <span class="pl-c1">*</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">b</span>
<span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-s1">nums</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
    <span class="pl-c1">a</span>: <span class="pl-c1">3</span><span class="pl-kos">,</span>
    <span class="pl-c1">b</span>: <span class="pl-c1">4</span>
<span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-s1">newSum</span> <span class="pl-c1">=</span> <span class="pl-en">sum</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-s1">nums</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">)</span>
<span class="pl-s1">newSum</span><span class="pl-kos">(</span><span class="pl-c1">3</span><span class="pl-kos">)</span></pre></div>
<h4>注意事项(Note)</h4>
<ul>
<li>每次绑定都返回一个新函数</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="// 点击事件绑定`bind`方法生成的一个匿名函数。会导致无法取消绑定。
element.addEventListener('click', o.say.bind(o))
// 因此下面的代码无效
element.removeEventListener('click', o.say.bind(o))
// 正确解法：
var _say = o.say.bind(o)
element.addEventListener('click', _say)
element.removeEventListener('click', _say)
"><pre><span class="pl-c">// 点击事件绑定`bind`方法生成的一个匿名函数。会导致无法取消绑定。</span>
<span class="pl-s1">element</span><span class="pl-kos">.</span><span class="pl-en">addEventListener</span><span class="pl-kos">(</span><span class="pl-s">'click'</span><span class="pl-kos">,</span> <span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-c1">say</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-s1">o</span><span class="pl-kos">)</span><span class="pl-kos">)</span>
<span class="pl-c">// 因此下面的代码无效</span>
<span class="pl-s1">element</span><span class="pl-kos">.</span><span class="pl-en">removeEventListener</span><span class="pl-kos">(</span><span class="pl-s">'click'</span><span class="pl-kos">,</span> <span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-c1">say</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-s1">o</span><span class="pl-kos">)</span><span class="pl-kos">)</span>
<span class="pl-c">// 正确解法：</span>
<span class="pl-k">var</span> <span class="pl-s1">_say</span> <span class="pl-c1">=</span> <span class="pl-s1">o</span><span class="pl-kos">.</span><span class="pl-c1">say</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-s1">o</span><span class="pl-kos">)</span>
<span class="pl-s1">element</span><span class="pl-kos">.</span><span class="pl-en">addEventListener</span><span class="pl-kos">(</span><span class="pl-s">'click'</span><span class="pl-kos">,</span> <span class="pl-s1">_say</span><span class="pl-kos">)</span>
<span class="pl-s1">element</span><span class="pl-kos">.</span><span class="pl-en">removeEventListener</span><span class="pl-kos">(</span><span class="pl-s">'click'</span><span class="pl-kos">,</span> <span class="pl-s1">_say</span><span class="pl-kos">)</span></pre></div>
<ul>
<li><code>bind</code>方法的兼容(Polyfill)</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }
    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          return fToBind.apply(this instanceof fNOP
                 ? this
                 : oThis,
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };
    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype;
    }
    fBound.prototype = new fNOP();
    return fBound;
  };
}
"><pre><span class="pl-c">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</span>
<span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-c1">!</span><span class="pl-v">Function</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">bind</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-v">Function</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-en">bind</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">oThis</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-k">typeof</span> <span class="pl-smi">this</span> <span class="pl-c1">!==</span> <span class="pl-s">'function'</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
      <span class="pl-c">// closest thing possible to the ECMAScript 5</span>
      <span class="pl-c">// internal IsCallable function</span>
      <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-v">TypeError</span><span class="pl-kos">(</span><span class="pl-s">'Function.prototype.bind - what is trying to be bound is not callable'</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>
    <span class="pl-k">var</span> <span class="pl-s1">aArgs</span>   <span class="pl-c1">=</span> <span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">slice</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-smi">arguments</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">)</span><span class="pl-kos">,</span>
        <span class="pl-s1">fToBind</span> <span class="pl-c1">=</span> <span class="pl-smi">this</span><span class="pl-kos">,</span>
        <span class="pl-en">fNOP</span>    <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span><span class="pl-kos">}</span><span class="pl-kos">,</span>
        <span class="pl-en">fBound</span>  <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
          <span class="pl-k">return</span> <span class="pl-s1">fToBind</span><span class="pl-kos">.</span><span class="pl-en">apply</span><span class="pl-kos">(</span><span class="pl-smi">this</span> <span class="pl-k">instanceof</span> <span class="pl-en">fNOP</span>
                 ? <span class="pl-smi">this</span>
                 : <span class="pl-s1">oThis</span><span class="pl-kos">,</span>
                 <span class="pl-s1">aArgs</span><span class="pl-kos">.</span><span class="pl-en">concat</span><span class="pl-kos">(</span><span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">slice</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-smi">arguments</span><span class="pl-kos">)</span><span class="pl-kos">)</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span><span class="pl-kos">;</span>
    <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
      <span class="pl-c">// Function.prototype doesn't have a prototype property</span>
      <span class="pl-en">fNOP</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span> <span class="pl-c1">=</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">;</span>
    <span class="pl-kos">}</span>
    <span class="pl-en">fBound</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span> <span class="pl-c1">=</span> <span class="pl-k">new</span> <span class="pl-en">fNOP</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
    <span class="pl-k">return</span> <span class="pl-en">fBound</span><span class="pl-kos">;</span>
  <span class="pl-kos">}</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span></pre></div>
<ul>
<li>结合<code>call</code>方法使用</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="[1, 2, 3].slice(0, 1) // [1]
// 等同
Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]
// `call`方法实质是调用`Function.prototype.call`方法
var slice = Function.prototype.call.bind(Array.prototype.slice)
slice([1, 2, 3], 0, 1) // [1]
"><pre><span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">]</span><span class="pl-kos">.</span><span class="pl-en">slice</span><span class="pl-kos">(</span><span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">)</span> <span class="pl-c">// [1]</span>
<span class="pl-c">// 等同</span>
<span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">slice</span><span class="pl-kos">.</span><span class="pl-en">call</span><span class="pl-kos">(</span><span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">]</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">)</span> <span class="pl-c">// [1]</span>
<span class="pl-c">// `call`方法实质是调用`Function.prototype.call`方法</span>
<span class="pl-k">var</span> <span class="pl-s1">slice</span> <span class="pl-c1">=</span> <span class="pl-v">Function</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">call</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">slice</span><span class="pl-kos">)</span>
<span class="pl-s1">slice</span><span class="pl-kos">(</span><span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">]</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">)</span> <span class="pl-c">// [1]</span></pre></div>
<ul>
<li>利用<code>bind</code>方法，将<code>[1, 2, 3].slice(0, 1)</code>变成了<code>slice([1, 2, 3], 0, 1)</code>的形式。这种改变也可以应用到其他数组方法。</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="var pop = Function.prototype.call.bind(Array.prototype.pop)
var push = Function.prototype.call.bind(Array.prototype.push)
var shift = Function.prototype.call.bind(Array.prototype.shift)
var map = Function.prototype.call.bind(Array.prototype.map)
// ...
var a = [1, 2, 3]
pop(a) // [1, 2]
push(a, 5) // [1, 2, 5]
shift(a) // [2, 5]
map(a, i =&gt; i+1) // [3, 6]
"><pre><span class="pl-k">var</span> <span class="pl-s1">pop</span> <span class="pl-c1">=</span> <span class="pl-v">Function</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">call</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">pop</span><span class="pl-kos">)</span>
<span class="pl-k">var</span> <span class="pl-s1">push</span> <span class="pl-c1">=</span> <span class="pl-v">Function</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">call</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">push</span><span class="pl-kos">)</span>
<span class="pl-k">var</span> <span class="pl-s1">shift</span> <span class="pl-c1">=</span> <span class="pl-v">Function</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">call</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">shift</span><span class="pl-kos">)</span>
<span class="pl-k">var</span> <span class="pl-s1">map</span> <span class="pl-c1">=</span> <span class="pl-v">Function</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">call</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-v">Array</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">map</span><span class="pl-kos">)</span>
<span class="pl-c">// ...</span>
<span class="pl-k">var</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">]</span>
<span class="pl-s1">pop</span><span class="pl-kos">(</span><span class="pl-s1">a</span><span class="pl-kos">)</span> <span class="pl-c">// [1, 2]</span>
<span class="pl-s1">push</span><span class="pl-kos">(</span><span class="pl-s1">a</span><span class="pl-kos">,</span> <span class="pl-c1">5</span><span class="pl-kos">)</span> <span class="pl-c">// [1, 2, 5]</span>
<span class="pl-s1">shift</span><span class="pl-kos">(</span><span class="pl-s1">a</span><span class="pl-kos">)</span> <span class="pl-c">// [2, 5]</span>
<span class="pl-s1">map</span><span class="pl-kos">(</span><span class="pl-s1">a</span><span class="pl-kos">,</span> <span class="pl-s1">i</span> <span class="pl-c1">=&gt;</span> <span class="pl-s1">i</span><span class="pl-c1">+</span><span class="pl-c1">1</span><span class="pl-kos">)</span> <span class="pl-c">// [3, 6]</span></pre></div>
<ul>
<li>将<code>Function.prototype.call</code>绑定到<code>Function.prototype.bind</code>对象，<code>bind</code>的调用形式也可以被改写</li>
</ul>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="function foo() {
    console.log(this.name)
}
var o = {name: 'lencx'}
var bind = Function.prototype.call.bind(Function.prototype.bind)
bind(foo, o)() // lencx
"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">name</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-s1">o</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-c1">name</span>: <span class="pl-s">'lencx'</span><span class="pl-kos">}</span>
<span class="pl-k">var</span> <span class="pl-s1">bind</span> <span class="pl-c1">=</span> <span class="pl-v">Function</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">call</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-v">Function</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-c1">bind</span><span class="pl-kos">)</span>
<span class="pl-s1">bind</span><span class="pl-kos">(</span><span class="pl-s1">foo</span><span class="pl-kos">,</span> <span class="pl-s1">o</span><span class="pl-kos">)</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c">// lencx</span></pre></div>
<h2>参考资料</h2>
<ul>
<li>MDN Web Docs:
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow">this</a>,</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="nofollow">defineProperty</a>,</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="nofollow">call</a>,</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="nofollow">bind</a>,</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="nofollow">apply</a></li>
</ul>
</li>
</ul>]]></description>
</item>
<item>
  <title><![CDATA[WebGL系列]]></title>
  <link>https://github.com/lencx/fzj/discussions/6</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/6</guid>
  <pubDate>2021-06-16</pubDate>
  <description><![CDATA[<h2>Guide</h2>
<ul>
<li>Modern WebGL tutorials that teach WebGL from basic principles
<ul>
<li><a href="https://webglfundamentals.org" rel="nofollow">WebGL Fundamentals</a></li>
<li><a href="https://webgl2fundamentals.org" rel="nofollow">WebGL2 Fundamentals</a></li>
</ul>
</li>
</ul>
<h2>Open Source</h2>
<ul>
<li><a href="https://github.com/oframe/ogl">ogl</a> - Minimal WebGL Library</li>
<li><a href="https://github.com/oasis-engine/engine">oasis-engine</a> - Oasis Engine is a web-first and mobile-first high-performance real-time development platform.</li>
<li><a href="https://github.com/deepkolos/three-platformize">three-platformize</a> - 一个让 THREE 平台化的项目，目前已适配微信，淘宝，头条小程序，微信小游戏</li>
</ul>]]></description>
</item>
<item>
  <title><![CDATA[React状态管理]]></title>
  <link>https://github.com/lencx/fzj/discussions/11</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/11</guid>
  <pubDate>2021-06-16</pubDate>
  <description><![CDATA[<h2>Open Source</h2>
<ul>
<li><a href="https://github.com/facebookexperimental/recoil">recoil</a> - Recoil is an experimental state management library for React apps. It provides several capabilities that are difficult to achieve with React alone, while being compatible with the newest features of React.</li>
<li><a href="https://github.com/reduxjs/react-redux">react-redux</a> - Official React bindings for Redux.
<ul>
<li><a href="https://github.com/reduxjs/redux-toolkit">@reduxjs/toolkit</a> - The official, opinionated, batteries-included toolset for efficient Redux development</li>
</ul>
</li>
<li><a href="https://github.com/mobxjs/mobx">mobx</a> - Simple, scalable state management.</li>
<li><a href="https://github.com/dvajs/dva">dva</a> -  <g-emoji class="g-emoji" alias="seedling" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f331.png">🌱</g-emoji> React and redux based, lightweight and elm-style framework. (Inspired by elm and choo)
<ul>
<li><a href="https://github.com/umijs/plugins/tree/master/packages/plugin-model">@umijs/plugin-model</a> -A simple state management solution based on hooks (can be replacement of dva in some cases).</li>
</ul>
</li>
<li><a href="https://github.com/immerjs/immer">immer</a> - Create the next immutable state by mutating the current one.</li>
<li><a href="https://github.com/jamiebuilds/unstated-next">unstated-next</a> - 200 bytes to never think about React state management libraries ever again.</li>
<li><a href="https://github.com/effector/effector">effector</a> - The state manager <g-emoji class="g-emoji" alias="comet" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2604.png">☄️</g-emoji></li>
<li><a href="https://github.com/pmndrs/valtio">valtio</a> - <g-emoji class="g-emoji" alias="pill" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f48a.png">💊</g-emoji> Valtio makes proxy-state simple for React and Vanilla.</li>
<li><a href="https://github.com/ctrlplusb/easy-peasy">easy-peasy</a> - Vegetarian friendly state for React.</li>
<li><a href="https://github.com/diegohaz/constate">constate</a> - React Context + State</li>
<li><a href="https://github.com/RisingStack/react-easy-state">react-easy-state</a> - Simple React state management. Made with <g-emoji class="g-emoji" alias="heart" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png">❤️</g-emoji> and ES6 Proxies.</li>
<li><a href="https://github.com/lostpebble/pullstate">pullstate</a> - Simple state stores using immer and React hooks - re-use parts of your state by pulling it anywhere you like!</li>
</ul>
<h2>Browser Extension</h2>
<ul>
<li><a href="https://github.com/reduxjs/redux-devtools">Redux DevTools</a> - DevTools for Redux with hot reloading, action replay, and customizable UI.</li>
</ul>]]></description>
</item>
<item>
  <title><![CDATA[技术名词解释 - 云服务]]></title>
  <link>https://github.com/lencx/fzj/discussions/31</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/31</guid>
  <pubDate>2021-06-17</pubDate>
  <description><![CDATA[<h2>云计算</h2>
<p>云计算（英语：cloud computing），也被意译为网络计算，是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其他设备，使用服务商提供的电脑基建作计算和资源。</p>
<p>云计算是指在云中运行工作负载，而云是一种能够抽象、汇集和共享整个网络中的可扩展资源的 IT 环境。云计算和云本身都不属于技术的范畴。</p>
<ul>
<li>云计算是指在云中运行工作负载的功能。</li>
<li>而云是一种环境，是运行应用的地方。</li>
<li>技术则是指用于构建和使用云的软件和硬件。</li>
</ul>
<h3>SaaS</h3>
<p>软件即服务（英语：Software as a Service，缩写：SaaS，发音：sæs或sɑs），亦可称为“按需即用软件”（即“一经要求，即可使用”），它是一种软件交付模式。在这种交付模式中，软件仅需通过网络，不须经过传统的安装步骤即可使用，软件及其相关的数据集中托管于云端服务。用户通常使用精简客户端，一般即经由网页浏览器来访问、访问软件即服务。SaaS 最大的特色在于软件本身并没有被下载到用户的硬盘，而是存储在提供商的云端或者服务器。对比传统软件需要花钱购买，下载。软件即服务只需要用户租用软件，在线使用，不但大大减少了用户购买风险, 也无需下载软件本身，无设备要求的限制。</p>
<h3>IaaS</h3>
<p>基础设施即服务（英语：Infrastructure as a Service，简称IaaS）是提供消费者处理、储存、网络以及各种基础运算资源，以部署与执行操作系统或应用程序等各种软件。</p>
<p>IaaS 是云服务的最底层，主要提供一些基础资源。它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。 客户端无须购买服务器、软件等网络设备，即可任意部署和运行处理、存储、网络和其它基本的计算资源，不能控管或控制底层的基础设施，但是可以控制操作系统、储存装置、已部署的应用程序，有时也可以有限度地控制特定的网络元件，像是主机端防火墙。</p>
<h3>PaaS</h3>
<p>平台即服务（英语：platform as a service，缩写：PaaS）是一种云计算服务，提供运算平台与解决方案服务。在云计算的典型层级中，PaaS层介于软件即服务与基础设施即服务之间。</p>
<p>PaaS提供用户将云端基础设施部署与创建至客户端，或者借此获得使用编程语言、程序库与服务。用户不需要管理与控制云端基础设施（包含网络、服务器、操作系统或存储），但需要控制上层的应用程序部署与应用托管的环境。</p>
<p>PaaS将软件研发的平台做为一种服务，以软件即服务（SaaS）模式交付给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。</p>
<p>PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。</p>
<h3>BaaS</h3>
<p>后端即服务 (BaaS) 使开发人员可以专注于应用程序的前端，无需构建或维护后端服务即可利用。BaaS 和无服务器计算有一些相似之处，许多提供商都提供两者，但是两种模型有一些差异。</p>
<h3>FaaS</h3>
<p>功能即服务 (FaaS) 是一类云计算服务，它提供了一个平台，允许客户开发、运行和管理应用程序功能，而无需构建和维护通常与开发和启动应用程序相关的基础设施。按照此模型构建应用程序是实现“无服务器”架构的一种方式，通常用于构建微服务应用程序。</p>
<h3>DaaS</h3>
<p>在计算领域，数据即服务（Data as a service，简称DaaS）是指在线数据服务，开发者将开发用的数据保存在互联网上并随时访问，而无需使用保存在本地计算机上的数据库。</p>
<hr>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97" rel="nofollow">[wiki] 云计算</a></li>
<li><a href="https://www.redhat.com/zh/topics/cloud" rel="nofollow">什么是云计算？</a></li>
<li><a href="https://www.redhat.com/zh/topics/cloud-native-apps/what-is-serverless" rel="nofollow">什么是无服务器？</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1" rel="nofollow">[wiki] 软件即服务</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%8F%B0%E5%8D%B3%E6%9C%8D%E5%8A%A1" rel="nofollow">[wiki] 平台即服务</a></li>
<li><a href="https://azure.microsoft.com/zh-cn/overview/what-is-paas" rel="nofollow">什么是 PaaS？</a></li>
<li><a href="https://www.redhat.com/zh/topics/cloud-computing/what-is-paas" rel="nofollow">什么是平台即服务（PaaS）？PaaS SaaS IaaS 区别解析</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mobile_backend_as_a_service" rel="nofollow">[wiki] Mobile backend as a service</a></li>
<li><a href="https://www.cloudflare.com/zh-cn/learning/serverless/glossary/backend-as-a-service-baas/" rel="nofollow">什么是 BaaS？|后端即服务与无服务器</a></li>
<li><a href="https://en.wikipedia.org/wiki/Function_as_a_service" rel="nofollow">Function as a service</a></li>
<li><a href="https://www.cloudflare.com/zh-cn/learning/serverless/glossary/function-as-a-service-faas/" rel="nofollow">什么功能即服务 (FaaS)？</a></li>
<li><a href="https://www.redhat.com/zh/topics/cloud-native-apps/what-is-faas" rel="nofollow">什么是功能即服务（FaaS）？</a></li>
<li><a href="https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/" rel="nofollow">从IaaS到FaaS—— Serverless架构的前世今生</a></li>
<li><a href="https://www.ibm.com/cloud/learn/faas" rel="nofollow">FaaS (Function-as-a-Service)</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A%E5%8D%B3%E6%9C%8D%E5%8B%99" rel="nofollow">[wiki] 数据即服务</a></li>
</ul>]]></description>
</item>
<item>
  <title><![CDATA[静态网站生成器]]></title>
  <link>https://github.com/lencx/fzj/discussions/7</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/7</guid>
  <pubDate>2021-06-15</pubDate>
  <description><![CDATA[<blockquote>
<p>文档及建站</p>
</blockquote>
<h2>Rust</h2>
<ul>
<li><a href="https://github.com/rust-lang/mdBook">mdbook</a> - Create book from markdown files. Like Gitbook but implemented in Rust.
<ul>
<li><a href="https://github.com/lzanini/mdbook-katex">mdbook-katex</a> - A preprocessor for mdBook, rendering LaTex equations to HTML at build time.</li>
<li><a href="https://github.com/badboy/mdbook-mermaid">mdbook-mermaid</a> - A preprocessor for mdbook to add mermaid support.</li>
</ul>
</li>
<li><a href="https://github.com/cobalt-org/cobalt.rs">cobalt</a> - Static site generator written in Rust.</li>
<li><a href="https://github.com/getzola/zola">zola</a> - A fast static site generator in a single binary with everything built-in.</li>
</ul>
<h2>Node.js</h2>
<ul>
<li>Vue
<ul>
<li><a href="https://vuepress.vuejs.org" rel="nofollow">VuePress</a> - Vue-powered Static Site Generator.</li>
<li><a href="https://vitepress.vuejs.org" rel="nofollow">VitePress</a> - VitePress is VuePress' little brother, built on top of Vite.</li>
<li><a href="https://sli.dev" rel="nofollow">Slidev</a> - Presentation Slides for Developers.</li>
</ul>
</li>
<li>React
<ul>
<li><a href="https://www.gatsbyjs.com" rel="nofollow">Gatsby</a> - Gatsby provides development teams an open source frontend framework for creating rich, optimized websites and a cloud platform for delivering them on a blazing fast edge network.</li>
<li><a href="https://d.umijs.org" rel="nofollow">dumi</a> - A doc tool can assist you to develop libraries &amp; write docs.</li>
</ul>
</li>
<li><a href="https://hexo.io" rel="nofollow">Hexo</a> - A fast, simple &amp; powerful blog framework.</li>
<li><a href="https://github.com/11ty/eleventy">eleventy <g-emoji class="g-emoji" alias="clock11" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f55a.png">🕚</g-emoji><g-emoji class="g-emoji" alias="zap" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png">⚡️</g-emoji></a> - A simpler static site generator. An alternative to Jekyll. Transforms a directory of templates (of varying types) into HTML.</li>
</ul>
<h2>Other</h2>
<ul>
<li><a href="https://github.com/jgm/pandoc">pandoc</a> - Universal markup converter</li>
</ul>]]></description>
</item>
<item>
  <title><![CDATA[黑客与画家 (Hackers & Painters)]]></title>
  <link>https://github.com/lencx/fzj/discussions/25</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/25</guid>
  <pubDate>2021-06-14</pubDate>
  <description><![CDATA[<blockquote>
<p><a href="http://www.paulgraham.com" rel="nofollow">作者: 保羅·格雷厄姆 (Paul Graham)</a><br>
<a href="http://www.ruanyifeng.com" rel="nofollow">译: 阮一峰</a></p>
</blockquote>
<hr>
<ul>
<li>
<p>出于兴趣而解决某个难题，不管它有没有用，这就是黑客。</p>
</li>
<li>
<p>黑客伦理(hacker ethic)</p>
<ul>
<li>使用计算机以及所有有助于了解这个世界本质的事物都不应该受到任何限制。任何事情都应该亲手尝试。<br>
(Access to computers-and anything that might teach you something about the way the world works-should be unlimited and total. Always yield to the Hands-On Imperative!)</li>
<li>信息应该全部免费。<br>
(All information should be free.)</li>
<li>不信任权威，提倡去中心化。<br>
(Mistrust Authority-Promote Decentralization.)</li>
<li>判断一名黑客的水平应该看他的技术能力，而不是看他的学历、年龄或地位等其他标准。<br>
(Hackers should be judged by their hacking, not bogus criteria such as degrees, age, race, or position.)</li>
<li>你可以用计算机创造美和艺术。<br>
(You can create art and beauty on a computer.)</li>
<li>计算机使生活更美好。<br>
(Computers can change your life for the better.)</li>
</ul>
<p><strong>根据这六条“黑客伦理”，黑客价值观的核心原则可以概括成这样几点：分享、开放、民主、计算机的自由使用、进步。</strong></p>
</li>
<li>
<p>计算机程序只是文本而已。你选择什么语言，决定了你能说什么话。编程语言就是程序员的思维方式。</p>
</li>
</ul>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Leon_Battista_Alberti" rel="nofollow">阿尔伯蒂</a>有一句名言：“任何一种艺术，不管是否重要，如果你想要在该领域出类拔萃，就必须全身心投入。”</li>
</ul>
<h2>黑客与画家</h2>
<ul>
<li>
<p>黑客搞懂“计算理论”(theory of computation)的必要性，与画家搞懂颜料化学成分的必要性差不多大。一般来说，在理论上，你需要知道如何计算“时间复杂度”和“空间复杂度”(time and space complexity)；如果你要写一个解释器，可能还需要知道状态机(state machine)的概念；除此以外，并不需要知道特别多的理论。这些可比画家必须记住的颜料成分少很多。</p>
</li>
<li>
<p>因为如果你不爱一件事，你不可能把它做得真正优秀，要是你很热爱编程，你就不可避免地会开发你自己的项目。</p>
</li>
<li>
<p>黑客就像画家，工作起来是有心理周期的。有时候，你有了一个令人兴奋的新项目，你会愿意为它一天工作16个小时。等过了这一阵，你又会觉得百无聊赖，对所有事情都提不起兴趣。</p>
</li>
<li>
<p>对于编程，这实际上意味着你可以把<code>bug</code>留到以后解决。消灭<code>bug</code>对我来说属于轻松的工作，只有在这个时候，编程才变得直接和机械，接近社会大众想象中的编程的样子。消灭<code>bug</code>的过程就像解一道数学题，已知许许多多的约束条件，你只要根据条件对方程求解就可以了。你的程序应该能产生x结果，但是却产生了y结果。哪里出错了？你知道自己最后肯定能够解决这个问题，所以做起来很轻松，就好像刷墙一样，接近于休闲了。</p>
</li>
<li>
<p>“程序写出来是为了让人看懂它的算法，附带告诉计算机如何执行。”一种好的编程语言应该比英语更容易解释软件。只有在那些不太成熟、容易出现问题的地方，你才应该加上注释，提醒读者注意那里，就好像公路上只有在急转弯处才会出现警示标志一样。</p>
</li>
</ul>
<h2>不能说的话</h2>
<ul>
<li>
<p>大多数成年人故意让孩子对世界有一个错误的认识。最鲜明的例子之一就是圣诞老人。我们觉得，小孩子相信圣诞老人，真是太可爱了。我本人其实也是这样想。但是，扪心自问，我们向孩子灌输圣诞老人的神话，到底是为了孩子，还是为了我们自己？</p>
<p>我在这里不讨论这样做是否正确。家长想要塑造孩子的心灵，把他们装扮成可爱的小宝宝，这可能是无法避免的。我也可能这样做。但是，就本文而言，这样做会产生一个重要的结果，那就是孩子“被迫”在一个精心设计的环境中长大。他的头脑或多或少是纯洁无暇的，一点也不知道那些“不能说的话”，从来没有被真实的社会生活“污染”过。孩子眼里的世界是不真实的，是一个被灌输进他们头脑的假想世界。将来当孩子长大以后接触社会，就会发现小时候以为真实的事情，在是现实世界中是荒唐可笑的。</p>
</li>
<li>
<p>那些团体神经越紧张，它们所产生的禁止力量就越大。伽利略因为宣布日心说而遭到教廷的审判，这件事讽刺的地方在于，他只是在宣传哥白尼的观点，而后者却安然无恙。事实上，哥白尼不仅不反对教廷，还是一个虔诚的天主教教士，他把自己的著作献给教皇。不幸的是，伽利略正赶上教廷内部反对派上台，宗教改革制度压制，任何非正统的思想遭受到前所未有的严厉控制和禁止。</p>
<p>为了在全社会制造出一个禁忌，负责实施的团体必定既不是特别强大也不是特别弱小。如果一个团体强大到无比自信，它根本不会在乎别人的抨击。美国人或者英国人对国外媒体的诋毁就毫不在意。但是一个团体太弱小，就会无力推行禁忌。有一种行为怪癖叫做“嗜粪症”(coprophila)，它的患者人数以及影响势力眼下似乎就不太强大，无法把自己的观点推广给其他人。</p>
<p>我猜想，道德禁忌的最大制造者是那些权利斗争中略占上风的一方。你会发现，这一方有实力推行禁忌，同时又软弱到需要用禁忌来保护自己的利益。</p>
<p>大多数的斗争，不管它们实际上争的是什么，都会以思想斗争的形式表现出来。</p>
</li>
</ul>
<h2>为什么这样做</h2>
<ul>
<li>
<p>有人可能会问，为什么要去找出“不能说的话”？为什么要故意打探那些龌龊的，见不得人的思想观点？你明知那里有挡住去路的石头，为什么还要把它们翻过来看个究竟呢？</p>
<p>首先，我这样做与小孩子翻石头是出于同样的原因：纯粹的好奇心。我对任何被禁止的东西都有特别强烈的好奇心。我要亲眼看一下，然后自己做决定。</p>
<p>其次，我这样做是因为我不喜欢犯错。如果像其他时代一样，那些我们自以为正确的事情将来会被证明是荒唐可笑的，我希望自己能够知道是哪些事情，这样可以使我不会上当。</p>
<p>再次，我这样做，是因为这是很好的脑力训练。<code>想要做出优秀作品，你需要一个什么问题都能思考的大脑。尤其是那些似乎不应该思考的问题，你的大脑也要养成思考它们的习惯。</code></p>
<p>优秀作品往往来自于其他人忽视的想法，而最被忽视的想法就是那些被禁止的思想观点。</p>
</li>
<li>
<p>“守口如瓶”的真正缺点在于，你从此无法享受讨论带来的好处了，讨论一个观点会产生更多的观点，不讨论就什么观点也没有。所以，如果可能的话，你最好找一些信得过的知己，只与他们畅所欲言、无所不谈。这样不仅可以获得新观点，还可以用来选择朋友。能够一起谈论“异端邪说”并且不会因此气急败坏的人，就是你最应该认识的朋友。</p>
</li>
<li>
<p>你不仅要远距离观察人群，更要远距离观察你自己。顺便提一句，这可不是激进的想法。儿童和成年人的主要差别就在这里。儿童精疲力竭时，可能会大发脾气，因为他不知道为了什么；成年人则会了解是个人的身体状况问题，与外界无关，说一句“没关系，我只是累了”。我想，通过类似的机制，一个人完全可以识别和抵制外界流行的道德观念，把它们与内心世界相分离。</p>
<p>如果你想要清晰的思考，就必须远离人群。但是走的越远，你的处境就会越困难，受到的阻力也会越大，因为你没有迎合社会习俗，而是一步步地与它背道而驰。小时候，每个人都会鼓励你不断成长，变成一个心智成熟、不再耍小孩脾气的人。但是，很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。</p>
<p>如果自己就是潮水的一部分，怎么能看见潮流的方向呢？你只能永远保持质疑。问自己，什么话是我不能说的？为什么？</p>
</li>
</ul>
<h2>另一条路</h2>
<ul>
<li>
<p>如果软件的新版本要等一年后才能发布，我就会把大部分新构思束之高阁，至少过上一段时间再来考虑。但是，构思这种东西有一个特点，那就是它会导致更多的构思。你有没有注意过，坐下来写东西的时候，一半的构思是写作时产生的？软件也是这样。实现某个构思，会带来更多的构思。所以，将一个构思束之高阁，不仅意味着延迟它的实现，还意味着延迟所有在实现过程中激发的构思。事实上，将一个构思束之高阁，甚至会限制新构思的产生。因为你看一眼堆放在一边、还没实现的构思，就会想“我已经为下一个版本准备了很多新东西要实现了”，你就懒得再去思考更多的新功能了。</p>
</li>
<li>
<p>现在，创业公司有更多的理由选择互联网软件创业，因为开发桌面软件越来越乏味了。如果你现在开发桌面软件，就不得不接受微软公司的授权条款，调用它的API，为它那个bug百出的操作系统伤透脑筋。历尽千辛万苦，你最终写出了一个受大众欢迎的软件，这时你可能会发现，你所做的一切其实只是在为微软公司做市场调查。</p>
</li>
<li>
<p>你能够做到这一点，意味着竞争者也能做到这一点，所以长时间工作变成了一种必须，不得不如此。<code>因为你能做到，所以你必须做到</code>。这简直就是逆向的<a href="https://en.wikipedia.org/wiki/Law_of_triviality" rel="nofollow">帕金森定律</a></p>
</li>
<li>
<p>不少公司都很想知道，什么事情可以外包，什么事情不可以外包，一个可能的答案是，公司内部所有不直接感受的竞争压力的部门都应该外包出去，让它们暴露在竞争压力之下。（我这里所说的“外包”，指的是聘请另一家公司来执行，而不是指把业务部门转移到海外。）</p>
</li>
<li>
<p>由于个人经历的关系，特雷弗·布莱克韦尔对这一点的认识可能比其他任何人都深刻。他写到：“我会进一步说，由于互联网软件的程序员非常辛苦，所以会使得经济优势根本性地从大公司向创业公司转移。互联网软件要求的那种工作强度和付出，只有当公司是其本人所有时，程序员才愿意提供。软件公司可以雇用到能干的人，让他们去干轻松的事情，也可以雇到不能干的人，让他们去干艰苦的事情。但是无法雇到非常能干的人，让他们去干非常艰苦的事情。因为互联网软件的创业不需要太多的资本，所以大公司可以与创业公司竞争的优势就所剩无几了。”</p>
</li>
</ul>
<h2>如何创造财富</h2>
<ul>
<li>
<p>交换媒介的优点是，它使得交易可以进行下去。缺点是，它往往模糊了交易的实质。人们觉得做生意就是为了挣钱，但是金钱其实只是一种中介，让大家可以更方便地获得自己想要的东西。大多数生意的目的是为了创造财富，做出人们真正需要的东西。</p>
</li>
<li>
<p>金钱不是财富，而只是我们用来转移财富所有权的的东西。</p>
</li>
<li>
<p>公司就是许多人聚在一起创造财富的地方，能够制造更多人们需要的东西。</p>
</li>
<li>
<p>我们这个世界，你向下沉沦或者向上奋进都取决于你自己，不能把原因推给外界。</p>
</li>
<li>
<p>一个大学毕业生总是想“我需要一份工作”，别人也是这么对他说的，好像变成某个组织的成员是一件多么重要的事情。更直接的表达方式应该是“你需要去做一些人们需要的东西”。即使不加入公司，你也能做到。公司不过是一群人在一起工作，共同做出某种人们需要的东西。真正重要的是做出人们需要的东西，而不是加入某个公司。</p>
<p>对于大多数人来说，最好的选择可能是为某个现存的公司打工。但是，理解这种行为的真正含义对你没有什么坏处。工作就是在一个组织中，与许多人共同合作，做出某种人们需要的东西。</p>
</li>
<li>
<p>要致富，你需要两样东西：<code>可测量性</code>和<code>可放大性</code>。你的职位产生的业绩，应该是可测量的，否则你做的再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做出的决定能够产生巨大的效应。</p>
</li>
<li>
<p>如果你有一个令你感到安全的工作，你是不会致富的，因为没有危险，就几乎等于没有可放大性。</p>
</li>
<li>
<p>乔布斯曾经说过，创业的成败取决于最早加入公司的那十个人。我基本同意这个观点，虽然我觉得真正决定成败的其实 只是前五人。小团队的优势不在于它本身的小，而在于你可以选择成员。我们不需要小村庄的那种“小 ”，而需要全明星第一阵容的那种“小”。</p>
</li>
<li>
<p>什么是技术？技术就是某种手段，就是我们做事的方式。如果你发现了一种做事的新方式，它的经济价值就取决于有多人使用这种新方式。技术就是钓鱼的鱼竿，而不是那条鱼。</p>
</li>
<li>
<p>只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。</p>
</li>
<li>
<p>“财富”这个词有很多意思，有些并不是指物质财富。我不想做深入讨论，研究到底什么才是真正的财富。我这里指的只是一种特定的技术层面上的“财富” ——人们用金钱向你交换东西。这是一种很有趣、很值得研究的财富，因为它使得你免于饥饿，而且人们是否用金钱交换这种财富取决于他们，而不是取决于你。</p>
</li>
</ul>
<h2>关注贫富分化</h2>
<ul>
<li>
<p><code>事实上，财富和金钱是两个概念。金钱只是用来交易财富的一种手段</code>，财富才是有价值的东西，我们购买的商品和服务都属于财富。你到 海外旅游时，不用看当地人的银行账户就会知道你来到的是富国还是穷国。你只要看看他们的财富就行了：建筑、街道、服装、健康状况等。</p>
</li>
<li>
<p>技术的发展使得通过创造而积累财富的速度第一次有可能超过通过偷窃而积累财富的速度。19世纪典型的富人不是宫廷朝臣，而是实业家。</p>
</li>
</ul>
<h2>设计者的品味</h2>
<ul>
<li>
<p>对于建筑师和设计者，它意味着美依赖于一些精心选择的结构性元素，而不是依赖于表面装饰品的堆砌。(装饰品本身并不是坏事，只有它被用来掩盖结构的苍白时，才变成了一件坏事。)</p>
</li>
<li>
<p>如果解决方法是丑陋的，那就肯定还有更好的解决方法，只是还没有发现而已。</p>
</li>
<li>
<p>白描其实是最难画的视觉媒介，因为它们要求近乎完美的再现。用数学语言说，线条属于闭合解(closed-form-solution)，水平不够的艺术家没有办法直接解决问题，只能通过不断逼近来求解。</p>
</li>
<li>
<p>人们有时会说自己有了“状态”，我的理解是，他们这时可以控制自己的脊髓。脊髓是更本能的反应，面对难题时，它能释放你的直觉。</p>
</li>
<li>
<p>好设计是模仿大自然的设计。我不是说模仿大自然这种行为本身有多么好，而是说大自然在长期的演化中已经解决了很多设计问题。所以，如果你的设计与大自然很接近，那么它基本上不会很差。</p>
</li>
</ul>
<h2>一百年后的编程语言</h2>
<ul>
<li>
<p>在长期的职业生涯中，我发现冗余的代码会导致更多冗余的代码，不仅软件如此，而且像我这样性格懒散的人，我发现在床底下和房间的角落里这个命题也成立，一件垃圾会产生更多的垃圾。</p>
</li>
<li>
<p>编程语言进化缓慢的原因在于它们并不是真正的技术。语言只是一种书写法，而程序则是一种严格符合规则的描述，以书面形式记录计算机应该如何解决你的问题。所以，编程语言的进化速度更像数学符号的进化速度，而不像真正的技术(比如交通或者通信技术)的进化速度。数学符号的进化是缓慢的渐变式变化，而不是真正技术的那种跳跃式发展。</p>
</li>
<li>
<p>我已经预测到了，一旦未来硬件的性能大幅提高将会发生什么事。新增加的运算能力都会被糟蹋掉。</p>
<p>在我学习编程的年代，计算机还是稀罕玩意。我记得当时使用的微机型号是TRS-80，它的内存只有4K，为了把BASIC程序装入内存，我不得不把源码中的空格全部删除。我一想到那些极其低效率的软件，不断重复某些愚蠢的运算，把硬件的计算能力全部占用，就感到无法忍受。但是，我的这种反应是错的，我就像某个出身贫寒的穷孩子，一听到要花钱就舍不得，即使把钱用在重要场合(比如去医院看病)都会觉得难以接受。</p>
</li>
</ul>
<h2>书呆子的复仇</h2>
<ul>
<li>如果你想在软件业获得成功，就使用你知道的最强大的语言，用它解决你知道的最难的问题，并且等待竞争对手的经理做出自甘平庸的选择。</li>
</ul>
<h2>梦寐以求的编程语言</h2>
<ul>
<li>
<p>编程语言不是存在于真空之中，“编程”其实是及物动词，黑客一般都是为某个系统编程。在现实中，编程语言总是与它们依附的系统联系在一起的。</p>
</li>
<li>
<p>无法以一种语言本身的优缺点评判这种语言。另一个结果则是，只有当一种语言是某个系统的脚本语言时，它才能真正成为编程语言。如果你对此很吃惊，觉得不公平，那么我会跟你说不必大惊小怪。这就好比大家都认为，如果一种编程语言只有语法规则，没有一个好的实现(implementation)，那么它就不能算完整的编程语言。这些都是很正常很合理的事情，编程语言本来就该如此。</p>
</li>
<li>
<p>你只需要不停地重复同一句话，最终人们将会开始倾听。人们真正注意到你的时候，不是第一眼就看到你站在那里，而是发现过了这么久你居然还在那里。</p>
</li>
<li>
<p>著名散文家E.B.怀特说过，“最好的文字来自不停的修改”。</p>
</li>
<li>
<p>为了写出优秀软件，你必须同时具备两种相互冲突的信念。一方面，你要像初生牛犊一样，对自己的能力信心万丈；另一方面，你又要像历经沧桑的老人一样，对自己的能力抱着怀疑态度。在你的大脑中，有一个声音说：“千难万险只等闲”，还有一个声音却说“早岁哪知世事艰”。</p>
<p>这里的难点在于你要意识到，实际上两种信念并不矛盾。你的乐观主义和怀疑倾向分别针对两个不同的对象。你必须对解决难题的可能性保持乐观，同时对当前解法的合理性保持怀疑。</p>
<p>做出优秀成果的人，在做的过程中常常觉得自己做得不够好。其他人看到他们的成果觉得棒极了，而创造者本人看到的都是自己作品的缺陷。这种视角的差异并非偶然，因为只有对现状不满，才会造就杰出的成果。</p>
</li>
<li>
<p>因此现实中，尽管软件功能越来越强大，内部接口却往往一成不变，成为整个系统中拖后腿的部分。</p>
<p>一种可能的解决方法是，将软件内部的接口设计成垂直接口而不是水平接口。这意味着软件内部的模块是一个个垂直堆积起来的抽象层，层与层之间的接口完全由其中的一层控制。如果较高的一层使用了较低的一层定义的语言，那么接口就由较低的一层控制；如果较低的一层从属于较高的一层，那么接口就由较高的一层控制。</p>
</li>
<li>
<p>帕金森定律(Parkinson's Law)的一种原始表达形式是“工作总是到最后一刻才会完成”，后来引申到计算机领域就变成了“数据总是会填满所有的空间”，更一般性的总结则是：“对一种资源的需求总是会消耗光这种资源的所有供应”。</p>
</li>
</ul>
<h2>设计与研究</h2>
<ul>
<li>
<p>设计与研究的区别看来就在于，前者追求“好”(good)，后者追求“新”(new)。优秀的设计不一定很“新”，但必须是“好”的；优秀的研究不一定很“好”，但必须是“新”的。我认为这两条道路最后会发生交叉：只有应用“新”的创新和理论，才会诞生超越前人的最佳设计；只有解决那些值得解决的难题(也就是“好”的难题)，才会诞生最佳研究。所以，最终来说，设计和研究都通向同一个地方，只是前进的路线不同罢了。</p>
</li>
<li>
<p>怎么理解编程语言？你不要把它看成那些已完成的程序的表达方式，而应该把它理解成促进程序从无到有的一种媒介。这里的意思是说，成品的材料和开发时用的材料其实是不一样的。搞艺术的人都知道，这两个阶段往往需要不同的媒介。比如，大理石是一种非常良好、耐用的材料，很适合用于最后的成品，但是它极其缺乏弹性和灵活性，所以不适合在构思阶段用来做模型。</p>
<p>最后写出来的程序就像已经完成的数学证明一样，是一棵经过精心修剪的树木，上面杂乱滋生的树杈 都已经被剪去了。所以，评价一种语言的优劣不能简单地看最后的程序是否表达得很漂亮，而要看程序从无到有的那条完成路径是否很漂亮。</p>
</li>
<li>
<p>画家之间甚至流传着一句谚语：<code>“画作永远没有完工的一天，你只是不再画下去而已。”</code></p>
</li>
<li>
<p>“弱即是强”指的是一种软件传播的模式，由Common Lisp专家里查德·加布里埃尔(Richard P. Gabriel)于1991年在<a href="http://www.dreamsongs.com/WIB.html" rel="nofollow">Lisp: Good News, Bad News, How to Win Big</a>一文中首先提出。它的含义非常广泛，涉及软件设计思想的各个方面，其中的一个重要结论就是软件功能的增加并不必然带来质量的提高。有时候，更少的功能(“弱”)反而是更好的选择(“强”)，因为这会使得软件的可用性提高。相比那些体积庞大、功能全面、较难上手的软件，一种功能有限但易于使用的软件可能对用户有更大的吸引力。加布里埃尔本人经常举Unix和C语言的例子，Unix和C在设计上考虑了实际环境，放弃了一些功能，但是保证了简单性，这使得它们最终在竞争中胜出，成为主流操作系统和编程语言。</p>
</li>
</ul>
<h2>术语解释</h2>
<ul>
<li><code>抽象(abstract)</code>: 隐藏细节。编程语言越抽象，你写出程序所需的运算步骤就越少，每一步的功能就越强。</li>
<li><code>算法(algorithm)</code>: 完成任务的方法。</li>
<li><code>Blub困境(Blub Paradox)</code>: 程序员的思想往往会受到自己正在使用的语言的束缚，不相信还存在更强大的语言。</li>
<li><code>复杂性(complexity)</code>: 算法的“时间复杂性”(time complexity) 指的是，当输入的数据量不断增加时，计算机完成过这种算法所消耗的时间</li>
<li><code>散列表(hash table)</code>: 一种类似数据库的数据结构，存储在里面的每一段数据都有一个对应的键，使用时只要按照键名就可以取出对应的数据。</li>
<li><code>函数库(library)</code>: 已经写好的代码片段，可以用来执行特定任务。</li>
<li><code>宏(macro)</code>: 一个能够生成其他程序的程序。</li>
<li><code>元循环(metacircular)</code>: 当一种语言的解释器用这种语言本身开发时，就会出现这种情况。与其说这是为了做出这种语言的一种实现，还不如说这是描述语言的一种技巧。</li>
<li><code>方法(method)</code>: 面向对象编程中充当某个类的属性的一个子程序。</li>
<li><code>模块(module)</code>: 一组子程序和变量，它们可以被视为是一个整体。通常情况下，模块外部的代码只能访问模块内部一部分专门对外公开的子程序和变量</li>
<li><code>目标码(object code)</code>: 编译器产生的机器语言。</li>
<li><code>OO(面向对象 object-oriented)</code>: 一种组织程序的方式。假定不同的类代表不同类型的数据，那么针对这些数据执行某种特定任务的代码，可以根据数据的不同被分别写进不同的类，成为这些类的方法。</li>
<li><code>正交的(orthogonal)</code>: 彼此独立、能够以多种方式组合在一起的一组东西。(乐高积木)</li>
<li><code>解析器(parser)</code>: 读取输入的数据然后生成解析树的程序。</li>
<li><code>解析树(parser tree)</code>: 解析器读取源码后生成的数据结构。它是将源码翻译成机器语言的第一步。</li>
<li><code>管道(pipe)</code>: 将操作系统的各种命令连接起来的一种方式，使得一个命令的输出变成另一个命令的输入。</li>
<li><code>指针(pointer)</code>: 一块数据，它的值是另一块数据的内存地址。</li>
<li><code>进程(process)</code>: 在同时运行多个程序的操作系统中，同时被运行的程序之一。</li>
<li><code>QA(质量保证，Quality Assurance)</code>: 软件行业中负责找出和登记bug的人。</li>
<li><code>递归(recursive)</code>: 一种调用自身的算法。</li>
</ul>]]></description>
</item>
<item>
  <title><![CDATA[人总是喜欢在固有思维下钻牛角尖]]></title>
  <link>https://github.com/lencx/fzj/discussions/30</link>
  <guid isPermaLink="false">https://github.com/lencx/fzj/discussions/30</guid>
  <pubDate>2021-06-14</pubDate>
  <description><![CDATA[<p><strong><code>2021.02.28</code></strong></p>
<p>最近这段时间写了一个基于 <code>vite</code> 的 <code>wasm-pack</code> (<code>Rust -&gt; Wasm</code>) 插件，遇到一个比较有意思的问题。</p>
<h3>需求</h3>
<p>实现一个 <code>rsw 插件</code>，当 vite 服务启动后，插件会自动调用 <code>wasm-pack</code> 的 cli，进行 build，生成 wasm 的 npm 包，当 rust 包目录下的文件变更时，能够进行重新进行 build (热更新)。</p>
<h3>问题</h3>
<p>实现需求其实很简单，但是如果只是这样实现插件，虽然能用，但是体验不好。每次启动服务都会先执行 cli 的 build (耗时有点长)，vite 的快速启动开发环境的体验全无。其实不分析也知道，cli 的 build 并非每次启动都需要执行。如果已经 build 过，则不需要再次执行。</p>
<p>于是，就有了第一版简单粗暴的实现方案，直接看目录中有没有 build 的文件存在，如果文件存在，则直接跳过执行，否则，执行 build。短短几行代码似乎就解决了问题。</p>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="// 核心代码：如果`package.json`存在则跳过执行
// https://github.com/lencx/vite-plugin-rsw/blob/69668e9bdb8322382e5d49d3e85b67a35354d7e0/src/compiler.ts#L82-L88
const pkgPath = path.resolve(root, getCrateName(_crate), 'pkg');
// vite startup optimization
try {
  fs.statSync(`${pkgPath}/package.json`).isFile();
  console.log(chalk.yellow(`[rsw::optimized] wasm-pack build ${getCrateName(_crate)}`));
} catch (e) {
  compileOne({ config: opts, crate: _crate, sync: true });
}
"><pre><span class="pl-c">// 核心代码：如果`package.json`存在则跳过执行</span>
<span class="pl-c">// https://github.com/lencx/vite-plugin-rsw/blob/69668e9bdb8322382e5d49d3e85b67a35354d7e0/src/compiler.ts#L82-L88</span>
<span class="pl-k">const</span> <span class="pl-s1">pkgPath</span> <span class="pl-c1">=</span> <span class="pl-s1">path</span><span class="pl-kos">.</span><span class="pl-en">resolve</span><span class="pl-kos">(</span><span class="pl-s1">root</span><span class="pl-kos">,</span> <span class="pl-en">getCrateName</span><span class="pl-kos">(</span><span class="pl-s1">_crate</span><span class="pl-kos">)</span><span class="pl-kos">,</span> <span class="pl-s">'pkg'</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-c">// vite startup optimization</span>
<span class="pl-k">try</span> <span class="pl-kos">{</span>
  <span class="pl-s1">fs</span><span class="pl-kos">.</span><span class="pl-en">statSync</span><span class="pl-kos">(</span><span class="pl-s">`<span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">pkgPath</span><span class="pl-kos">}</span></span>/package.json`</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">isFile</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
  <span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">chalk</span><span class="pl-kos">.</span><span class="pl-en">yellow</span><span class="pl-kos">(</span><span class="pl-s">`[rsw::optimized] wasm-pack build <span class="pl-s1"><span class="pl-kos">${</span><span class="pl-en">getCrateName</span><span class="pl-kos">(</span><span class="pl-s1">_crate</span><span class="pl-kos">)</span><span class="pl-kos">}</span></span>`</span><span class="pl-kos">)</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span> <span class="pl-k">catch</span> <span class="pl-kos">(</span><span class="pl-s1">e</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-en">compileOne</span><span class="pl-kos">(</span><span class="pl-kos">{</span> <span class="pl-c1">config</span>: <span class="pl-s1">opts</span><span class="pl-kos">,</span> <span class="pl-c1">crate</span>: <span class="pl-s1">_crate</span><span class="pl-kos">,</span> <span class="pl-c1">sync</span>: <span class="pl-c1">true</span> <span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span></pre></div>
<p>但是很快就打脸了，有一种情况是未考虑到的，就是在停止服务后修改文件，当启动服务后，因为之前 build 的文件一直都存在，所以并不会执行 build，只有在启动服务后，修改文件，才会触发热更新。</p>
<p>解决这个问题，我一直在想如何去缓存文件信息，做比较，如果两次文件内容都无变化，则文件未被修改过，但是又想到，如果文件特别多，<code>存储读取</code>又会产生新的问题，感觉问题被复杂化了，但是却没什么头绪。</p>
<p>和朋友讨论这个插件，朋友的一句话点醒了我。不需要存储读取文件，因为文件内容是不需要关心的，我们其实更关心的问题是文件是否被修改，而文件是否修改，可以通过查看文件修改时间。因为 build 是后于源码修改的，所以源码的修改时间一定小于 build 目录下的文件时间。如果源码修改时间大于了 build 目录下的文件时间。则表示文件修改了，但未执行 build。</p>
<p>这也就有了下面这段代码</p>
<div class="highlight highlight-source-js position-relative" data-snippet-clipboard-copy-content="// 核心代码：比较文件变更时间
// https://github.com/lencx/vite-plugin-rsw/blob/8aa0d68750/src/utils.ts#L85-L127
try {
  // benchmark file modified time
  const pkgMtime = fs.statSync(benchmarkFile).mtimeMs;
  const cargoMtime = fs.statSync(cargoToml).mtimeMs;
  let isOptim = true;

  // run wasm-pack
  if (cargoMtime &gt; pkgMtime) {
    isOptim = false;
    return runCallback();
  }

  (function dirsMtime(dir) {
    for (let f of fs.readdirSync(dir)) {
      const _f = fs.statSync(`${dir}/${f}`);

      if (_f.isDirectory()) {
        if (_f.mtimeMs &gt; pkgMtime) {
          // run wasm-pack
          isOptim = false;
          runCallback();
          break;
        } else {
          dirsMtime(`${dir}/${f}`)
        }
      }

      if (_f.isFile()) {
        if (_f.mtimeMs &gt; pkgMtime) {
          // run wasm-pack
          isOptim = false;
          runCallback();
          break;
        }
      }
    }
  })(dirs)

  isOptim &amp;&amp; optimCallback();
} catch(e) {
  // no such file or directory
  runCallback();
}
"><pre><span class="pl-c">// 核心代码：比较文件变更时间</span>
<span class="pl-c">// https://github.com/lencx/vite-plugin-rsw/blob/8aa0d68750/src/utils.ts#L85-L127</span>
<span class="pl-k">try</span> <span class="pl-kos">{</span>
  <span class="pl-c">// benchmark file modified time</span>
  <span class="pl-k">const</span> <span class="pl-s1">pkgMtime</span> <span class="pl-c1">=</span> <span class="pl-s1">fs</span><span class="pl-kos">.</span><span class="pl-en">statSync</span><span class="pl-kos">(</span><span class="pl-s1">benchmarkFile</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-c1">mtimeMs</span><span class="pl-kos">;</span>
  <span class="pl-k">const</span> <span class="pl-s1">cargoMtime</span> <span class="pl-c1">=</span> <span class="pl-s1">fs</span><span class="pl-kos">.</span><span class="pl-en">statSync</span><span class="pl-kos">(</span><span class="pl-s1">cargoToml</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-c1">mtimeMs</span><span class="pl-kos">;</span>
  <span class="pl-k">let</span> <span class="pl-s1">isOptim</span> <span class="pl-c1">=</span> <span class="pl-c1">true</span><span class="pl-kos">;</span>

  <span class="pl-c">// run wasm-pack</span>
  <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">cargoMtime</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">pkgMtime</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-s1">isOptim</span> <span class="pl-c1">=</span> <span class="pl-c1">false</span><span class="pl-kos">;</span>
    <span class="pl-k">return</span> <span class="pl-en">runCallback</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
  <span class="pl-kos">}</span>

  <span class="pl-kos">(</span><span class="pl-k">function</span> <span class="pl-en">dirsMtime</span><span class="pl-kos">(</span><span class="pl-s1">dir</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-k">for</span> <span class="pl-kos">(</span><span class="pl-k">let</span> <span class="pl-s1">f</span> <span class="pl-k">of</span> <span class="pl-s1">fs</span><span class="pl-kos">.</span><span class="pl-en">readdirSync</span><span class="pl-kos">(</span><span class="pl-s1">dir</span><span class="pl-kos">)</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
      <span class="pl-k">const</span> <span class="pl-s1">_f</span> <span class="pl-c1">=</span> <span class="pl-s1">fs</span><span class="pl-kos">.</span><span class="pl-en">statSync</span><span class="pl-kos">(</span><span class="pl-s">`<span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">dir</span><span class="pl-kos">}</span></span>/<span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">f</span><span class="pl-kos">}</span></span>`</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

      <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">_f</span><span class="pl-kos">.</span><span class="pl-en">isDirectory</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">_f</span><span class="pl-kos">.</span><span class="pl-c1">mtimeMs</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">pkgMtime</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
          <span class="pl-c">// run wasm-pack</span>
          <span class="pl-s1">isOptim</span> <span class="pl-c1">=</span> <span class="pl-c1">false</span><span class="pl-kos">;</span>
          <span class="pl-en">runCallback</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
          <span class="pl-k">break</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span> <span class="pl-k">else</span> <span class="pl-kos">{</span>
          <span class="pl-en">dirsMtime</span><span class="pl-kos">(</span><span class="pl-s">`<span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">dir</span><span class="pl-kos">}</span></span>/<span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">f</span><span class="pl-kos">}</span></span>`</span><span class="pl-kos">)</span>
        <span class="pl-kos">}</span>
      <span class="pl-kos">}</span>

      <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">_f</span><span class="pl-kos">.</span><span class="pl-en">isFile</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
        <span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">_f</span><span class="pl-kos">.</span><span class="pl-c1">mtimeMs</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">pkgMtime</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
          <span class="pl-c">// run wasm-pack</span>
          <span class="pl-s1">isOptim</span> <span class="pl-c1">=</span> <span class="pl-c1">false</span><span class="pl-kos">;</span>
          <span class="pl-en">runCallback</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
          <span class="pl-k">break</span><span class="pl-kos">;</span>
        <span class="pl-kos">}</span>
      <span class="pl-kos">}</span>
    <span class="pl-kos">}</span>
  <span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">(</span><span class="pl-s1">dirs</span><span class="pl-kos">)</span>

  <span class="pl-s1">isOptim</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-en">optimCallback</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span> <span class="pl-k">catch</span><span class="pl-kos">(</span><span class="pl-s1">e</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-c">// no such file or directory</span>
  <span class="pl-en">runCallback</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span></pre></div>
<h3>总结</h3>
<p>人很容易在固有思维下钻牛角尖，走到最后才发现自己虽然很努力，但似乎方向不太对。和朋友聊天，或者让自己放松一下，可能会有不一样的收获。</p>
<h3>相关链接</h3>
<ul>
<li><a href="https://github.com/lencx/vite-plugin-rsw">vite-plugin-rsw</a></li>
<li><a href="https://rustwasm.github.io/wasm-pack" rel="nofollow">wasm-pack</a></li>
<li><a href="https://webassembly.org" rel="nofollow">wasm</a> - webAssembly的简称</li>
<li><a href="https://vitejs.dev" rel="nofollow">vite</a> - 下一代前端构建工具</li>
</ul>]]></description>
</item>

</channel>
</rss>